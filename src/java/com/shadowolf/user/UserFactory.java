package com.shadowolf.user;

import java.lang.ref.WeakReference;
import java.util.Comparator;
import java.util.Date;
import java.util.SortedSet;
import java.util.TreeSet;

import javolution.util.FastMap;

import org.apache.log4j.Logger;

import com.shadowolf.config.Config;
import com.shadowolf.tracker.AnnounceException;
import com.shadowolf.tracker.Errors;

/**
 * User factory classes that creates User instances. <br />
 * <br />
 * The storage / statistics tracking scheme that Shadowolf uses is as follows:<br />
 * <br />
 * Every unique torrent-client combination is a {@link com.shadowolf.user.Peer}. These are generated by this class. <br />
 * Each peer gets strongly referenced by a User instance. <br />
 * Every Peer also gets weakly referenced in a {@link com.shadowolf.user.PeerList}, based on info_hash, rather than user.
 * These are generated by {@link com.shadowolf.user.PeerListFactory}.<br />
 * Every passkey-peer_id combination is a User.  These are generated by {@link UserFactory}.<br />
 * <br />
 * Since every passkey, and thus every user in the database, can own up to 3 User instances, to get full stats, you need to
 * use {@link #aggregate(String)}, which also properly resets the user's stats so as not to corrupt user stats.
 */
final public class UserFactory {
	private static final boolean DEBUG = true;
	private static final Logger LOGGER = Logger.getLogger(UserFactory.class);
	private static FastMap<String, UserList> users;

	static {
		users = new FastMap<String, UserList>();
		users.shared();
	}

	private UserFactory() {}

	public static void cleanUp() {
		if(DEBUG) {
			LOGGER.debug("Cleaning up users...");
		}

		for(FastMap.Entry<String, UserList> n = users.head(), last = users.tail(); (n = n.getNext()) != last;) {
			n.getValue().cleanUp();
		}

		if(DEBUG) {
			LOGGER.debug("Finished cleanup");
		}
	}

	public static User getUser(final String key, final String passkey) throws AnnounceException {
		LOGGER.debug("Passkey: " + passkey + " num peers: " + getOrSetUser(passkey).getPeerCount() + " key " + key);
		if(getOrSetUser(passkey).getPeerCount() > Integer.parseInt(Config.getParameter("user.max_locations"))) {
			throw new AnnounceException(Errors.TOO_MANY_LOCATIONS);
		}
		
		return getOrSetUser(passkey).getPeerId(key);
	}

	public static User aggregate(final String passkey) {
		return getOrSetUser(passkey).aggregate();
	}

	private static UserList getOrSetUser(final String passkey) {
		UserList u = users.get(passkey);
		if(u == null) {
			u = new UserList(passkey);
			users.put(passkey, u);
		}
		
		return u;
	}
	
	private static class UserList {
		private final String passkey;
		private final FastMap<String, WeakReference<User>> peerIdTable;
		private final SortedSet<User> users;
		
		public UserList(final String passkey) {
			this.passkey = passkey;
			this.peerIdTable = new FastMap<String, WeakReference<User>>();
			this.peerIdTable.shared();
			
			this.users = new TreeSet<User>(new Comparator<User>() {

				@Override
				public int compare(User first, User second) {
					if(first.getLastAccessed() > second.getLastAccessed()) {
						return 1;
					} else if (first.getLastAccessed() == second.getLastAccessed()) {
						return 0;
					} else {
						return -1;
					}
				}
				
			});
		}
		
		public synchronized int getPeerCount() {
			return this.peerIdTable.size();
		}
		
		public synchronized User getPeerId(final String key) {
			WeakReference<User> weakRefU = this.peerIdTable.get(key);
			User u;
			
			if(weakRefU == null) {
				u = new User(key, this.passkey);
				weakRefU = new WeakReference<User>(u);
				this.peerIdTable.put(key, weakRefU);
			} else {
				u = weakRefU.get();
				
				if(u == null) {
					u = new User(key, this.passkey);
					weakRefU = new WeakReference<User>(u);
					this.peerIdTable.put(key, weakRefU);
				}
				
			}
			
			this.users.remove(u);
			this.users.add(u);
			return u;
		}
		
		public synchronized void cleanUp() {
			this.users.headSet(User.getEmptyInstance()).clear();
		}
		
		public synchronized User aggregate() {
			final UserAggregate user = new UserAggregate(this.passkey);

			if(DEBUG) {
				LOGGER.debug("Aggegating " + this.passkey + " with " + this.users.size() + " User instances.");
			}
			
			if(this.users.size() == 1) {
				return this.users.first();
			} else if(this.users.size() > 1) {
				for(final User u : this.users) {
					user.addDownloaded(u.resetDownloaded());
					user.addUploaded(u.resetUploaded());
					
					u.setLastAccessed(new Date().getTime());
					
					this.users.remove(u);
					this.users.add(u);
				}
			}
			return user;
		}
	}
}
